require './lib/connect_four.rb'

describe ConnectFour do
  describe '#create_2d_array' do
    it "returns a 2d array of the board" do
      game = ConnectFour.new
      game.create_2d_array
      expect(game.board).to eq(
        {
          [0, 0]=>"[ ]", [0, 1]=>"[ ]", [0, 2]=>"[ ]", [0, 3]=>"[ ]", [0, 4]=>"[ ]", [0, 5]=>"[ ]", [0, 6]=>"[ ]",
          [1, 0]=>"[ ]", [1, 1]=>"[ ]", [1, 2]=>"[ ]", [1, 3]=>"[ ]", [1, 4]=>"[ ]", [1, 5]=>"[ ]", [1, 6]=>"[ ]",
          [2, 0]=>"[ ]", [2, 1]=>"[ ]", [2, 2]=>"[ ]", [2, 3]=>"[ ]", [2, 4]=>"[ ]", [2, 5]=>"[ ]", [2, 6]=>"[ ]",
          [3, 0]=>"[ ]", [3, 1]=>"[ ]", [3, 2]=>"[ ]", [3, 3]=>"[ ]", [3, 4]=>"[ ]", [3, 5]=>"[ ]", [3, 6]=>"[ ]",
          [4, 0]=>"[ ]", [4, 1]=>"[ ]", [4, 2]=>"[ ]", [4, 3]=>"[ ]", [4, 4]=>"[ ]", [4, 5]=>"[ ]", [4, 6]=>"[ ]",
          [5, 0]=>"[ ]", [5, 1]=>"[ ]", [5, 2]=>"[ ]", [5, 3]=>"[ ]", [5, 4]=>"[ ]", [5, 5]=>"[ ]", [5, 6]=>"[ ]"
        }
      )
    end
  end

  describe '#win?' do
    it "returns true if player has winning combo in a row" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[ ]", [0, 1]=>"[ ]", [0, 2]=>"[ ]", [0, 3]=>"[ ]", [0, 4]=>"[ ]", [0, 5]=>"[ ]", [0, 6]=>"[ ]",
        [1, 0]=>"[ ]", [1, 1]=>"[ ]", [1, 2]=>"[ ]", [1, 3]=>"[ ]", [1, 4]=>"[ ]", [1, 5]=>"[ ]", [1, 6]=>"[ ]",
        [2, 0]=>"[ ]", [2, 1]=>"[ ]", [2, 2]=>"[ ]", [2, 3]=>"[ ]", [2, 4]=>"[ ]", [2, 5]=>"[ ]", [2, 6]=>"[ ]",
        [3, 0]=>"[ ]", [3, 1]=>"[ ]", [3, 2]=>"[1]", [3, 3]=>"[ ]", [3, 4]=>"[ ]", [3, 5]=>"[ ]", [3, 6]=>"[ ]",
        [4, 0]=>"[ ]", [4, 1]=>"[1]", [4, 2]=>"[1]", [4, 3]=>"[ ]", [4, 4]=>"[ ]", [4, 5]=>"[ ]", [4, 6]=>"[ ]",
        [5, 0]=>"[0]", [5, 1]=>"[0]", [5, 2]=>"[0]", [5, 3]=>"[0]", [5, 4]=>"[ ]", [5, 5]=>"[ ]", [5, 6]=>"[ ]"
      }

      expect(game.win).to eql(true)
    end

    it "returns true if player has winning combo in a column" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[ ]", [0, 1]=>"[ ]", [0, 2]=>"[ ]", [0, 3]=>"[ ]", [0, 4]=>"[ ]", [0, 5]=>"[ ]", [0, 6]=>"[ ]",
        [1, 0]=>"[ ]", [1, 1]=>"[ ]", [1, 2]=>"[ ]", [1, 3]=>"[ ]", [1, 4]=>"[ ]", [1, 5]=>"[ ]", [1, 6]=>"[ ]",
        [2, 0]=>"[ ]", [2, 1]=>"[1]", [2, 2]=>"[ ]", [2, 3]=>"[ ]", [2, 4]=>"[ ]", [2, 5]=>"[ ]", [2, 6]=>"[ ]",
        [3, 0]=>"[ ]", [3, 1]=>"[1]", [3, 2]=>"[1]", [3, 3]=>"[0]", [3, 4]=>"[ ]", [3, 5]=>"[ ]", [3, 6]=>"[ ]",
        [4, 0]=>"[ ]", [4, 1]=>"[1]", [4, 2]=>"[0]", [4, 3]=>"[0]", [4, 4]=>"[ ]", [4, 5]=>"[ ]", [4, 6]=>"[ ]",
        [5, 0]=>"[0]", [5, 1]=>"[1]", [5, 2]=>"[0]", [5, 3]=>"[1]", [5, 4]=>"[ ]", [5, 5]=>"[ ]", [5, 6]=>"[ ]"
      }
      expect(game.win).to eql(true)
    end

    it "returns true if player has winning combo in a diagonal" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[ ]", [0, 1]=>"[ ]", [0, 2]=>"[ ]", [0, 3]=>"[ ]", [0, 4]=>"[ ]", [0, 5]=>"[ ]", [0, 6]=>"[ ]",
        [1, 0]=>"[ ]", [1, 1]=>"[ ]", [1, 2]=>"[ ]", [1, 3]=>"[ ]", [1, 4]=>"[ ]", [1, 5]=>"[ ]", [1, 6]=>"[ ]",
        [2, 0]=>"[ ]", [2, 1]=>"[1]", [2, 2]=>"[ ]", [2, 3]=>"[0]", [2, 4]=>"[ ]", [2, 5]=>"[ ]", [2, 6]=>"[ ]",
        [3, 0]=>"[ ]", [3, 1]=>"[1]", [3, 2]=>"[0]", [3, 3]=>"[0]", [3, 4]=>"[ ]", [3, 5]=>"[ ]", [3, 6]=>"[ ]",
        [4, 0]=>"[ ]", [4, 1]=>"[0]", [4, 2]=>"[1]", [4, 3]=>"[0]", [4, 4]=>"[ ]", [4, 5]=>"[ ]", [4, 6]=>"[ ]",
        [5, 0]=>"[0]", [5, 1]=>"[1]", [5, 2]=>"[1]", [5, 3]=>"[1]", [5, 4]=>"[ ]", [5, 5]=>"[ ]", [5, 6]=>"[ ]"
      }
      expect(game.win).to eql(true)
    end

    it "returns false if player has only 3 combo in a diagonal" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[ ]", [0, 1]=>"[ ]", [0, 2]=>"[ ]", [0, 3]=>"[ ]", [0, 4]=>"[ ]", [0, 5]=>"[ ]", [0, 6]=>"[ ]",
        [1, 0]=>"[ ]", [1, 1]=>"[ ]", [1, 2]=>"[ ]", [1, 3]=>"[ ]", [1, 4]=>"[ ]", [1, 5]=>"[ ]", [1, 6]=>"[ ]",
        [2, 0]=>"[ ]", [2, 1]=>"[1]", [2, 2]=>"[ ]", [2, 3]=>"[1]", [2, 4]=>"[ ]", [2, 5]=>"[ ]", [2, 6]=>"[ ]",
        [3, 0]=>"[ ]", [3, 1]=>"[1]", [3, 2]=>"[0]", [3, 3]=>"[0]", [3, 4]=>"[ ]", [3, 5]=>"[ ]", [3, 6]=>"[ ]",
        [4, 0]=>"[ ]", [4, 1]=>"[0]", [4, 2]=>"[1]", [4, 3]=>"[0]", [4, 4]=>"[ ]", [4, 5]=>"[ ]", [4, 6]=>"[ ]",
        [5, 0]=>"[0]", [5, 1]=>"[1]", [5, 2]=>"[1]", [5, 3]=>"[1]", [5, 4]=>"[ ]", [5, 5]=>"[ ]", [5, 6]=>"[ ]"
      }
      expect(game.win).to eql(true)
    end
  end

  describe '#is_board_full' do
    it "returns true if board has no more spaces left" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[1]", [0, 1]=>"[1]", [0, 2]=>"[0]", [0, 3]=>"[0]", [0, 4]=>"[0]", [0, 5]=>"[1]", [0, 6]=>"[1]",
        [1, 0]=>"[0]", [1, 1]=>"[0]", [1, 2]=>"[1]", [1, 3]=>"[1]", [1, 4]=>"[1]", [1, 5]=>"[0]", [1, 6]=>"[1]",
        [2, 0]=>"[1]", [2, 1]=>"[1]", [2, 2]=>"[0]", [2, 3]=>"[1]", [2, 4]=>"[1]", [2, 5]=>"[1]", [2, 6]=>"[0]",
        [3, 0]=>"[0]", [3, 1]=>"[1]", [3, 2]=>"[0]", [3, 3]=>"[0]", [3, 4]=>"[1]", [3, 5]=>"[0]", [3, 6]=>"[1]",
        [4, 0]=>"[1]", [4, 1]=>"[0]", [4, 2]=>"[1]", [4, 3]=>"[0]", [4, 4]=>"[0]", [4, 5]=>"[1]", [4, 6]=>"[0]",
        [5, 0]=>"[0]", [5, 1]=>"[1]", [5, 2]=>"[0]", [5, 3]=>"[1]", [5, 4]=>"[1]", [5, 5]=>"[0]", [5, 6]=>"[0]"
      }
      expect(game.is_board_full).to eql(true)
    end

    it "returns true if board is empty" do
      game = ConnectFour.new
      game.board = {
          [0, 0]=>"[ ]", [0, 1]=>"[ ]", [0, 2]=>"[ ]", [0, 3]=>"[ ]", [0, 4]=>"[ ]", [0, 5]=>"[ ]", [0, 6]=>"[ ]",
          [1, 0]=>"[ ]", [1, 1]=>"[ ]", [1, 2]=>"[ ]", [1, 3]=>"[ ]", [1, 4]=>"[ ]", [1, 5]=>"[ ]", [1, 6]=>"[ ]",
          [2, 0]=>"[ ]", [2, 1]=>"[ ]", [2, 2]=>"[ ]", [2, 3]=>"[ ]", [2, 4]=>"[ ]", [2, 5]=>"[ ]", [2, 6]=>"[ ]",
          [3, 0]=>"[ ]", [3, 1]=>"[ ]", [3, 2]=>"[ ]", [3, 3]=>"[ ]", [3, 4]=>"[ ]", [3, 5]=>"[ ]", [3, 6]=>"[ ]",
          [4, 0]=>"[ ]", [4, 1]=>"[ ]", [4, 2]=>"[ ]", [4, 3]=>"[ ]", [4, 4]=>"[ ]", [4, 5]=>"[ ]", [4, 6]=>"[ ]",
          [5, 0]=>"[ ]", [5, 1]=>"[ ]", [5, 2]=>"[ ]", [5, 3]=>"[ ]", [5, 4]=>"[ ]", [5, 5]=>"[ ]", [5, 6]=>"[ ]"
        }
      expect(game.is_board_full).to eq(false)
    end

    it "returns false if board has one space left" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[1]", [0, 1]=>"[1]", [0, 2]=>"[ ]", [0, 3]=>"[0]", [0, 4]=>"[0]", [0, 5]=>"[1]", [0, 6]=>"[1]",
        [1, 0]=>"[0]", [1, 1]=>"[0]", [1, 2]=>"[1]", [1, 3]=>"[1]", [1, 4]=>"[1]", [1, 5]=>"[0]", [1, 6]=>"[1]",
        [2, 0]=>"[1]", [2, 1]=>"[1]", [2, 2]=>"[0]", [2, 3]=>"[1]", [2, 4]=>"[1]", [2, 5]=>"[1]", [2, 6]=>"[0]",
        [3, 0]=>"[0]", [3, 1]=>"[1]", [3, 2]=>"[0]", [3, 3]=>"[0]", [3, 4]=>"[1]", [3, 5]=>"[0]", [3, 6]=>"[1]",
        [4, 0]=>"[1]", [4, 1]=>"[0]", [4, 2]=>"[1]", [4, 3]=>"[0]", [4, 4]=>"[0]", [4, 5]=>"[1]", [4, 6]=>"[0]",
        [5, 0]=>"[0]", [5, 1]=>"[1]", [5, 2]=>"[0]", [5, 3]=>"[1]", [5, 4]=>"[1]", [5, 5]=>"[0]", [5, 6]=>"[0]"
      }
      expect(game.is_board_full).to eql(false)
    end
  end

  describe '#gameover?' do
    it "returns true if board is full && there is no winner" do
      game = ConnectFour.new
      game.board = {
        [0, 0]=>"[1]", [0, 1]=>"[1]", [0, 2]=>"[0]", [0, 3]=>"[0]", [0, 4]=>"[0]", [0, 5]=>"[1]", [0, 6]=>"[1]",
        [1, 0]=>"[0]", [1, 1]=>"[0]", [1, 2]=>"[1]", [1, 3]=>"[1]", [1, 4]=>"[1]", [1, 5]=>"[0]", [1, 6]=>"[1]",
        [2, 0]=>"[1]", [2, 1]=>"[1]", [2, 2]=>"[0]", [2, 3]=>"[1]", [2, 4]=>"[1]", [2, 5]=>"[1]", [2, 6]=>"[0]",
        [3, 0]=>"[0]", [3, 1]=>"[1]", [3, 2]=>"[0]", [3, 3]=>"[0]", [3, 4]=>"[1]", [3, 5]=>"[0]", [3, 6]=>"[1]",
        [4, 0]=>"[1]", [4, 1]=>"[0]", [4, 2]=>"[1]", [4, 3]=>"[0]", [4, 4]=>"[0]", [4, 5]=>"[1]", [4, 6]=>"[0]",
        [5, 0]=>"[0]", [5, 1]=>"[1]", [5, 2]=>"[0]", [5, 3]=>"[1]", [5, 4]=>"[1]", [5, 5]=>"[0]", [5, 6]=>"[0]"
      }
      expect(game.gameover).to eql(true)
    end
  end

end
